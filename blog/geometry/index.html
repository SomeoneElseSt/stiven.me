<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Geometry</title>
    <style>
/* cyrillic-ext */
@font-face {
  font-family: 'Inter';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: url(https://fonts.gstatic.com/s/inter/v20/UcCO3FwrK3iLTeHuS_nVMrMxCp50SjIw2boKoduKmMEVuLyfAZJhiI2B.woff2) format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C8A, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
/* cyrillic */
@font-face {
  font-family: 'Inter';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: url(https://fonts.gstatic.com/s/inter/v20/UcCO3FwrK3iLTeHuS_nVMrMxCp50SjIw2boKoduKmMEVuLyfAZthiI2B.woff2) format('woff2');
  unicode-range: U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
/* greek-ext */
@font-face {
  font-family: 'Inter';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: url(https://fonts.gstatic.com/s/inter/v20/UcCO3FwrK3iLTeHuS_nVMrMxCp50SjIw2boKoduKmMEVuLyfAZNhiI2B.woff2) format('woff2');
  unicode-range: U+1F00-1FFF;
}
/* greek */
@font-face {
  font-family: 'Inter';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: url(https://fonts.gstatic.com/s/inter/v20/UcCO3FwrK3iLTeHuS_nVMrMxCp50SjIw2boKoduKmMEVuLyfAZxhiI2B.woff2) format('woff2');
  unicode-range: U+0370-0377, U+037A-037F, U+0384-038A, U+038C, U+038E-03A1, U+03A3-03FF;
}
/* vietnamese */
@font-face {
  font-family: 'Inter';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: url(https://fonts.gstatic.com/s/inter/v20/UcCO3FwrK3iLTeHuS_nVMrMxCp50SjIw2boKoduKmMEVuLyfAZBhiI2B.woff2) format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+0300-0301, U+0303-0304, U+0308-0309, U+0323, U+0329, U+1EA0-1EF9, U+20AB;
}
/* latin-ext */
@font-face {
  font-family: 'Inter';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: url(https://fonts.gstatic.com/s/inter/v20/UcCO3FwrK3iLTeHuS_nVMrMxCp50SjIw2boKoduKmMEVuLyfAZFhiI2B.woff2) format('woff2');
  unicode-range: U+0100-02BA, U+02BD-02C5, U+02C7-02CC, U+02CE-02D7, U+02DD-02FF, U+0304, U+0308, U+0329, U+1D00-1DBF, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
/* latin */
@font-face {
  font-family: 'Inter';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: url(https://fonts.gstatic.com/s/inter/v20/UcCO3FwrK3iLTeHuS_nVMrMxCp50SjIw2boKoduKmMEVuLyfAZ9hiA.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
/* cyrillic-ext */
@font-face {
  font-family: 'Inter';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: url(https://fonts.gstatic.com/s/inter/v20/UcCO3FwrK3iLTeHuS_nVMrMxCp50SjIw2boKoduKmMEVuFuYAZJhiI2B.woff2) format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C8A, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
/* cyrillic */
@font-face {
  font-family: 'Inter';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: url(https://fonts.gstatic.com/s/inter/v20/UcCO3FwrK3iLTeHuS_nVMrMxCp50SjIw2boKoduKmMEVuFuYAZthiI2B.woff2) format('woff2');
  unicode-range: U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
/* greek-ext */
@font-face {
  font-family: 'Inter';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: url(https://fonts.gstatic.com/s/inter/v20/UcCO3FwrK3iLTeHuS_nVMrMxCp50SjIw2boKoduKmMEVuFuYAZNhiI2B.woff2) format('woff2');
  unicode-range: U+1F00-1FFF;
}
/* greek */
@font-face {
  font-family: 'Inter';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: url(https://fonts.gstatic.com/s/inter/v20/UcCO3FwrK3iLTeHuS_nVMrMxCp50SjIw2boKoduKmMEVuFuYAZxhiI2B.woff2) format('woff2');
  unicode-range: U+0370-0377, U+037A-037F, U+0384-038A, U+038C, U+038E-03A1, U+03A3-03FF;
}
/* vietnamese */
@font-face {
  font-family: 'Inter';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: url(https://fonts.gstatic.com/s/inter/v20/UcCO3FwrK3iLTeHuS_nVMrMxCp50SjIw2boKoduKmMEVuFuYAZBhiI2B.woff2) format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+0300-0301, U+0303-0304, U+0308-0309, U+0323, U+0329, U+1EA0-1EF9, U+20AB;
}
/* latin-ext */
@font-face {
  font-family: 'Inter';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: url(https://fonts.gstatic.com/s/inter/v20/UcCO3FwrK3iLTeHuS_nVMrMxCp50SjIw2boKoduKmMEVuFuYAZFhiI2B.woff2) format('woff2');
  unicode-range: U+0100-02BA, U+02BD-02C5, U+02C7-02CC, U+02CE-02D7, U+02DD-02FF, U+0304, U+0308, U+0329, U+1D00-1DBF, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
/* latin */
@font-face {
  font-family: 'Inter';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: url(https://fonts.gstatic.com/s/inter/v20/UcCO3FwrK3iLTeHuS_nVMrMxCp50SjIw2boKoduKmMEVuFuYAZ9hiA.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
@font-face {
  font-family: 'Inter Fallback';
  src: local('Arial');
  size-adjust: 106.5%;
  ascent-override: 90%;
  descent-override: 22%;
  line-gap-override: 0%;
}
        body { background: black; color: white; font-family: Inter, 'Inter Fallback', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; margin: 0; padding: 100px; }
        h1 { font-size: 24px; margin-bottom: 24px; }
        .blog-header { padding-top: 5px; }
        .blog-post-item { border-bottom: 1px solid #333; padding: 16px 0; }
        .blog-post-link { text-decoration: none; display: flex; justify-content: space-between; align-items: center; }
        .blog-post-title { display: block; font-weight: normal; font-size: 16px; line-height: 1.6; color: white; }
        .blog-post-date { font-size: 14px; opacity: 0.6; margin-left: 16px; color: white; }
        .social-links { margin-top: 16px; display: flex; gap: 24px; min-height: 20px; align-items: center; }
        .post-header { display: flex; justify-content: space-between; align-items: flex-start; max-width: 600px;} /* Modify margin-bottom to move text up/down */
        .post-header > div { flex: 1; }
        .post-header h1 { margin: 0; margin-bottom: 15px; font-size: 24px; font-weight: bold; line-height: 1.4; position: relative; top: 12px; } 
        #post-date.post-date { display: block; margin-bottom: 0; font-size: 14px; opacity: 0.7; margin-top: 22px; } /* Change margin top to modify post header height */
        .back-button { display: inline-block; font-size: 16px; text-decoration: none; white-space: nowrap; margin-left: 16px; color: white; line-height: 1.2; position: relative; top: 16px; } /* Change top to move back button up/down */
        article { max-width: 600px; }
        article a { color: white; text-decoration: underline; text-underline-offset: 4px; }
        article p { margin: 16px 0; }
        article blockquote { margin: 24px 0; padding: 4px 0 4px 16px; border-left: 2px solid rgba(255, 255, 255, 0.65); }
        article blockquote p { margin: 8px 0; }
        article h2 { font-size: 24px; margin-top: 32px; margin-bottom: 16px; }
        article h3 { font-size: 20px; margin-top: 24px; margin-bottom: 12px; }
        article img { max-width: 100%; height: auto; margin: 24px 0; }
        article details { margin: 0px 0; }
        article summary { cursor: pointer; }
        article details pre { margin: 2px 0 0; }
        .footnotes { font-size: 0.83em; margin-top: 32px; }
        .footnotes h2 { display: none; }
        .footnotes ol { padding-left: 1.5em; }
        .footnotes li { margin-bottom: 8px; }
        #nprogress .bar { background: white !important; height: 2px !important; }
        #nprogress .peg { box-shadow: 0 0 10px white, 0 0 5px white; }
        #nprogress .spinner { display: none !important; }
        @media (max-width: 768px) {
            body { padding: 24px; }
            .post-header { margin-top: 20px; } /* Change margin top to modify the padding between the title and empty space above */
            .social-links { margin-bottom: 150px; } /* Change margin bottom to add/reduce whitespace between the links and the footer */
        }
    </style>
    <link rel="preload" href="https://fonts.gstatic.com/s/inter/v20/UcCO3FwrK3iLTeHuS_nVMrMxCp50SjIw2boKoduKmMEVuLyfAZ9hiA.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="https://fonts.gstatic.com/s/inter/v20/UcCO3FwrK3iLTeHuS_nVMrMxCp50SjIw2boKoduKmMEVuFuYAZ9hiA.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="dns-prefetch" href="//cdnjs.cloudflare.com">
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.28/dist/katex.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
    <script type="module" src="/dist/init.js?v=1.2" defer></script>
</head>
<body>
    <div class="post-header">
        <div>
            <h1 id="post-title">Geometry</h1>
            <time id="post-date" class="post-date">January 29, 2026</time>
        </div>
        <a href="/" class="back-button">← Back</a>
    </div>
    
    <article id="post-content"><p>I have read many technical blogs that clarified my understanding of some topics in the past. Some notable shoutouts are <a href="https://colah.github.io/posts/2015-09-Visual-Information/">this</a> visual information theory breakdown, and <a href="https://logan-thomas.com/2021/01/23/maxwell-demon/">this</a> post on Maxwell&#39;s demon. They are both very thorough and I recommend you read them.</p>
<p>I think technical blogs are an essential source of knowledge, because in order for someone to write them, they need to understand deeply (and empirically) whatever they&#39;re trying to explain to you. Plus, they are also written in a way that you&#39;re supposed to understand, unlike papers. I encourage you to write one of your own!</p>
<p>This brief write-up is my first attempt to contribute back by illustrating some interesting geometrical properties of binomial events I found through a statistics class I&#39;m taking this semester. </p>
<p>Picture a fair coin. There are two outcomes: heads or tails, each with a 50% chance, respectively. </p>
<p>If you wanted to know the chances that this coin lands on heads <strong>N</strong> times consecutively, and each flip is independent, you can just multiply:</p>
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord text"><span class="mord">heads </span></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord text"><span class="mord"> times</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.6313em;vertical-align:-0.95em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.6812em;"><span style="top:-3.9029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span></span>
<p>Now, you probably already know these formulas if you took a probability class in college or high school. </p>
<p>What you might not have learned there is that geometry is a powerful way of describing probability, specifically when partitioning a set <strong>A</strong> with all the outcomes of interest. </p>
<p>3Blue1Brown&#39;s video on Bayes&#39; theorem does a great job of visualizing how one can consider all the possible outcomes (in their example, the profession of a group of people) as a rectangle that can be broken down into overlapping sections from which Bayes&#39; theorem can be derived. You can watch it <a href="https://www.youtube.com/watch?v=HZGCoVF3YvM">here</a>.</p>
<p>Applying this to the coin toss question, we can visualize all the possible heads and tails sequences (&#39;HHHTTT&#39;, &#39;HTHTHT&#39;, &#39;HHHHHH&#39;, etc) one may get after tossing a coin six times with a similar visualization: a sample space. A sample space is a visualization of all the possible discrete outcomes or paths that may happen for a given experiment. In this example, coin toss sequences. </p>
<p><img src="/blog/assets/coin-sample-space-n-6.png" alt="Sample Space for 6 Consecutive [Independent] Coin Tosses" title="Coin Sample Space"></p>
<details>
<summary>Show visualization code</summary>

<pre><code class="language-py">import matplotlib.pyplot as plt
import numpy as np

num_flips = 6  # Visualize 6 flips

fig, ax = plt.subplots(figsize=(14, 8), facecolor=&#39;black&#39;)
ax.set_facecolor(&#39;black&#39;)

colors = plt.cm.Blues(np.linspace(0.3, 0.9, num_flips + 1))

def outcome_to_sequence(outcome, length):
    if (length == 0):
        return &#39;&#39;
    bits = format(outcome, f&#39;0{length}b&#39;)
    return &#39;&#39;.join(&#39;H&#39; if bit == &#39;1&#39; else &#39;T&#39; for bit in bits)

for flip in range(num_flips + 1):
    total_outcomes = 2**flip
    height = 1 / total_outcomes
    
    # Draw all possible outcomes at this level
    for outcome in range(total_outcomes):
        y_position = outcome * height
        
        rect = plt.Rectangle((flip, y_position), 0.8, height, 
                            linewidth=1, edgecolor=&#39;black&#39;, 
                            facecolor=colors[flip], alpha=0.7)
        ax.add_patch(rect)
        
        if flip &lt;= 5:  # Label first few
            label = outcome_to_sequence(outcome, flip)
            ax.text(flip + 0.4, y_position + height/2, label, 
                   ha=&#39;center&#39;, va=&#39;center&#39;, fontsize=8)

ax.set_xlim(-0.5, num_flips + 0.5)
ax.set_ylim(0, 1)
ax.set_xlabel(&#39;Coin Flip Number&#39;, fontsize=12, color=&#39;white&#39;)
ax.set_ylabel(&#39;Probability space (0–1)&#39;, fontsize=12, color=&#39;white&#39;)
ax.set_title(f&#39;Sample Space Division: {num_flips} Coin Flips\n(Total outcomes = 2^{num_flips} = {2**num_flips})&#39;, fontsize=14, color=&#39;white&#39;)
ax.set_xticks(range(num_flips + 1))
ax.grid(axis=&#39;x&#39;, alpha=0.3, color=&#39;white&#39;)

ax.tick_params(colors=&#39;white&#39;)
for spine in ax.spines.values():
    spine.set_color(&#39;white&#39;)

plt.tight_layout()
plt.savefig(&#39;sample_space_tree.png&#39;, dpi=150)
plt.show()
</code></pre>
</details>

<p>The first block on the left shows the 0th coin flip. Since it has a guaranteed probability of happening, it occupies the whole Y-axis. The second block shows the outcome of the first coin toss. Since it can be either a head or a tail, it occupies two evenly spaced blocks. </p>
<p>Further to the right, each block doubles in its number of outcomes, which makes sense intuitively because we&#39;re expanding each coin toss with 2 children outcomes respectively.</p>
<p>The Y-axis gives the probability for each single path to happen according to its proportion. Paths along the center — with an even variation between heads and tails — occupy a bigger part of the Y-axis, as naturally, they&#39;re the most probable, while paths of consecutive heads or tails (either going fully down or up, in a staircase pattern), occupy an ever-decreasing proportion of the Y-axis, relative to their very low probabilities as shown below.</p>
<p><img src="/blog/assets/coin-sample-space-shaded-staircase.png" alt="Consecutive tails or heads shaded staircase." title="Consecutive tails or heads shaded staircase."></p>
<details>
<summary>Show visualization code</summary>

<pre><code class="language-py">import matplotlib.pyplot as plt
import numpy as np

num_flips = 6

fig, ax = plt.subplots(figsize=(14, 8), facecolor=&#39;black&#39;)
ax.set_facecolor(&#39;black&#39;)

colors = plt.cm.Blues(np.linspace(0.3, 0.9, num_flips + 1))

def outcome_to_sequence(outcome, length):
    if length == 0:
        return &#39;&#39;
    bits = format(outcome, f&#39;0{length}b&#39;)
    return &#39;&#39;.join(&#39;H&#39; if bit == &#39;1&#39; else &#39;T&#39; for bit in bits)

for flip in range(num_flips + 1):
    total_outcomes = 2**flip
    height = 1 / total_outcomes
    
    for outcome in range(total_outcomes):
        y_position = outcome * height
        
        # Highlight staircase: all T (outcome=0) or all H (outcome=max)
        is_staircase = (outcome == 0 or outcome == total_outcomes - 1)
        
        if is_staircase:
            facecolor = colors[-1]  # Darkest blue from the original scale
            alpha = 1.0
            edgecolor = &#39;white&#39;
        else:
            facecolor = colors[flip]
            alpha = 0.15
            edgecolor = &#39;black&#39;
        
        rect = plt.Rectangle((flip, y_position), 0.8, height, 
                            linewidth=1, edgecolor=edgecolor, 
                            facecolor=facecolor, alpha=alpha)
        ax.add_patch(rect)
        
        if flip &lt;= 5:
            label = outcome_to_sequence(outcome, flip)
            ax.text(flip + 0.4, y_position + height/2, label, 
                   ha=&#39;center&#39;, va=&#39;center&#39;, fontsize=8, color=&#39;white&#39;)

ax.set_xlim(-0.5, num_flips + 0.5)
ax.set_ylim(0, 1)
ax.set_xlabel(&#39;Coin Flip Number&#39;, fontsize=12, color=&#39;white&#39;)
ax.set_ylabel(&#39;Probability space (0–1)&#39;, fontsize=12, color=&#39;white&#39;)
ax.set_title(f&#39;Sample Space Division: {num_flips} Coin Flips\nShowing Shaded Staircases of Consecutive H/T Patterns.&#39;, fontsize=14, color=&#39;white&#39;)
ax.set_xticks(range(num_flips + 1))
ax.grid(axis=&#39;x&#39;, alpha=0.3, color=&#39;white&#39;)

ax.tick_params(colors=&#39;white&#39;)
for spine in ax.spines.values():
    spine.set_color(&#39;white&#39;)

plt.tight_layout()
plt.savefig(&#39;coin-sample-space-shaded-staircase.png&#39;, dpi=150)
plt.show()
</code></pre>
</details>

<p>Are you starting to see the link between geometry and probability here? You could measure the probability for any given sequence by picking its terminal block and measuring its height. It makes questions like how likely are you to get a specific sequence like &#39;HTHHTHH&#39; easy to answer; just trace the graph!  </p>
<p>So why is this important? As you may recall from the law of large numbers, over enough runs, outcomes average out to their true probabilities. If you flip a fair coin forever and count how many times you get heads or tails, the chance of getting either becomes 50% and 50%. The above graph doesn&#39;t really make this intuitive, though. After all, it seems like the most likely sequences simply collapse into blobs of increasing length.</p>
<p>But something is hiding in plain sight: a normal distribution. If we plot the proportion of times we get heads in the sample space as shown below, there is a clear bell shape before the true 50% proportion converges. </p>
<p><img src="/blog/assets/coin-sample-space-proportion-heads.png" alt="Proportion of Heads in the Coin Sample Space Over N=0 to N=100" title="Proportion of Heads in the Coin Sample Space Over N=0 to N=100"></p>
<details>
<summary>Show visualization code</summary>

<pre><code class="language-py">import matplotlib.pyplot as plt
import numpy as np
from scipy.special import comb

num_flips = 100

fig, ax = plt.subplots(figsize=(20, 14), facecolor=&#39;black&#39;)
ax.set_facecolor(&#39;black&#39;)

for flip in range(1, num_flips + 1):
    max_prob = comb(flip, flip // 2, exact=True) * (0.5 ** flip)
    marker_size = max(5, 200 / np.sqrt(flip))

    for num_heads in range(flip + 1):
        prob = comb(flip, num_heads, exact=True) * (0.5 ** flip)
        relative_prob = prob / max_prob
        color = plt.cm.RdYlBu_r(relative_prob)
        y_proportion = num_heads / flip

        ax.scatter(
            flip,
            y_proportion,
            c=[color],
            s=marker_size,
            marker=&#39;s&#39;,
            edgecolors=&#39;none&#39;,
            alpha=0.95,
            rasterized=True
        )

ax.axhline(
    y=0.5,
    color=&#39;white&#39;,
    linestyle=&#39;--&#39;,
    linewidth=3,
    alpha=0.9,
    label=&#39;Mean (50% heads)&#39;,
    zorder=10
)

flip_points = [10, 25, 50, 75, 100]
for flip in flip_points:
    std_dev = np.sqrt(flip * 0.5 * 0.5)
    std_proportion = std_dev / flip

    ax.plot(
        [flip, flip],
        [0.5 - std_proportion, 0.5 + std_proportion],
        &#39;yellow&#39;,
        linewidth=5,
        alpha=0.8,
        zorder=9
    )

    ax.plot(
        [flip, flip],
        [0.5 - 2 * std_proportion, 0.5 + 2 * std_proportion],
        &#39;orange&#39;,
        linewidth=3,
        alpha=0.6,
        zorder=8
    )

ax.set_xlim(0, num_flips + 2)
ax.set_ylim(0, 1)
ax.set_xlabel(&#39;Number of Coin Flips (n)&#39;, fontsize=16, fontweight=&#39;bold&#39;, color=&#39;white&#39;)
ax.set_ylabel(&#39;Proportion of Heads&#39;, fontsize=16, fontweight=&#39;bold&#39;, color=&#39;white&#39;)
ax.set_title(
    &#39;Proportion of Heads in the Sample Space\n&#39;
    &#39;A Normal Distribution Emerges Naturally&#39;,
    fontsize=17,
    fontweight=&#39;bold&#39;,
    pad=20,
    color=&#39;white&#39;
)

sm = plt.cm.ScalarMappable(cmap=plt.cm.RdYlBu_r, norm=plt.Normalize(vmin=0, vmax=1))
sm.set_array([])
cbar = plt.colorbar(sm, ax=ax, pad=0.01, fraction=0.046)
cbar.set_label(&#39;Relative Probability Density&#39;, fontsize=14, fontweight=&#39;bold&#39;, color=&#39;white&#39;)
cbar.ax.yaxis.set_tick_params(color=&#39;white&#39;)
plt.setp(plt.getp(cbar.ax.axes, &#39;yticklabels&#39;), color=&#39;white&#39;)

ax.legend(loc=&#39;upper right&#39;, fontsize=13, framealpha=0.9)

ax.tick_params(colors=&#39;white&#39;)
for spine in ax.spines.values():
    spine.set_color(&#39;white&#39;)

plt.tight_layout()
plt.savefig(&#39;coin-sample-space-proportion-heads.png&#39;, dpi=150, bbox_inches=&#39;tight&#39;, facecolor=&#39;black&#39;)
plt.show()
</code></pre>
</details>


<p>Now, we can see that the proportion will indeed even out to 50%, and if we expanded this to many more <strong>N</strong> we&#39;d end up seeing a completely straight line. </p>
<p>What&#39;s interesting is that at <strong>N</strong> &lt; 20 the distribution of outcomes is mostly normal. The yellow lines act as a visual aid: if we stopped sampling proportions at those lines, the center would follow the central limit theorem, accumulating most outcomes and smoothing out to a bell. </p>
<p>We can explain this intuitively by looking at the previous figure overlaid and mirrored on the sample space distribution plot: </p>
<p><img src="/blog/assets/coin-sample-space-overlay.png" alt="Overlay of the two previous plots with the sample space mirrored on top of proportion sample space." title="Overlay of the two previous plots with the sample space mirrored on top of proportion sample space."></p>
<details>
<summary>Show visualization code</summary>

<pre><code class="language-py">from pathlib import Path

import matplotlib.pyplot as plt
import numpy as np
from PIL import Image
from scipy.special import comb

NUM_FLIPS = 100
STAIRCASE_FLIPS = 6
BASE_FILENAME = &#39;coin-sample-space-proportion-heads-clean.png&#39;
STAIRCASE_FILENAME = &#39;coin-sample-space-shaded-staircase-clean.png&#39;
OUTPUT_FILENAME = &#39;coin-sample-space-overlay.png&#39;
ALPHA_SCALE = 0.5


def generate_distribution_base(output_path):
    fig, ax = plt.subplots(figsize=(20, 14), facecolor=&#39;black&#39;)
    ax.set_facecolor(&#39;black&#39;)

    for flip in range(1, NUM_FLIPS + 1):
        max_prob = comb(flip, flip // 2, exact=True) * (0.5 ** flip)
        marker_size = max(5, 200 / np.sqrt(flip))

        for num_heads in range(flip + 1):
            prob = comb(flip, num_heads, exact=True) * (0.5 ** flip)
            relative_prob = prob / max_prob
            color = plt.cm.RdYlBu_r(relative_prob)
            y_proportion = num_heads / flip

            ax.scatter(
                flip,
                y_proportion,
                c=[color],
                s=marker_size,
                marker=&#39;s&#39;,
                edgecolors=&#39;none&#39;,
                alpha=0.95,
                rasterized=True
            )

    ax.set_xlim(0, NUM_FLIPS + 2)
    ax.set_ylim(0, 1)
    ax.set_xticks([])
    ax.set_yticks([])

    for spine in ax.spines.values():
        spine.set_visible(False)

    plt.tight_layout()
    plt.savefig(output_path, dpi=150, bbox_inches=&#39;tight&#39;, facecolor=&#39;black&#39;)
    plt.close(fig)


def generate_staircase_overlay(output_path):
    fig, ax = plt.subplots(figsize=(14, 8), facecolor=&#39;black&#39;)
    ax.set_facecolor(&#39;black&#39;)

    colors = plt.cm.Blues(np.linspace(0.3, 0.9, STAIRCASE_FLIPS + 1))

    for flip in range(STAIRCASE_FLIPS + 1):
        total_outcomes = 2**flip
        height = 1 / total_outcomes

        for outcome in range(total_outcomes):
            y_position = outcome * height
            is_staircase = (outcome == 0 or outcome == total_outcomes - 1)

            if is_staircase:
                facecolor = colors[-1]
                alpha = 1.0
                edgecolor = &#39;white&#39;
            else:
                facecolor = colors[flip]
                alpha = 0.15
                edgecolor = &#39;black&#39;

            rect = plt.Rectangle(
                (flip, y_position),
                0.8,
                height,
                linewidth=1,
                edgecolor=edgecolor,
                facecolor=facecolor,
                alpha=alpha
            )
            ax.add_patch(rect)

    ax.set_xlim(-0.5, STAIRCASE_FLIPS + 0.5)
    ax.set_ylim(0, 1)
    ax.set_xticks([])
    ax.set_yticks([])

    for spine in ax.spines.values():
        spine.set_visible(False)

    plt.tight_layout()
    plt.savefig(output_path, dpi=150, bbox_inches=&#39;tight&#39;, facecolor=&#39;black&#39;)
    plt.close(fig)


def overlay_images(base_path, overlay_path, output_path):
    if not base_path.exists():
        print(f&#39;Missing base image: {base_path}&#39;)
        return
    if not overlay_path.exists():
        print(f&#39;Missing overlay image: {overlay_path}&#39;)
        return

    base = Image.open(base_path).convert(&#39;RGBA&#39;)
    overlay = Image.open(overlay_path).convert(&#39;RGBA&#39;)

    overlay_flipped = overlay.transpose(Image.FLIP_LEFT_RIGHT)
    overlay_resized = overlay_flipped.resize(base.size, Image.LANCZOS)

    r, g, b, a = overlay_resized.split()
    a = a.point(lambda v: int(v * ALPHA_SCALE))
    overlay_transparent = Image.merge(&#39;RGBA&#39;, (r, g, b, a))

    combined = Image.alpha_composite(base, overlay_transparent)
    combined.save(output_path)


def main():
    assets_dir = Path(__file__).resolve().parent.parent
    base_path = assets_dir / BASE_FILENAME
    staircase_path = assets_dir / STAIRCASE_FILENAME
    output_path = assets_dir / OUTPUT_FILENAME

    generate_distribution_base(base_path)
    generate_staircase_overlay(staircase_path)
    overlay_images(base_path, staircase_path, output_path)


main()
</code></pre>
</details>

<p>The edges of the bell line up with consecutive coin paths, which are very unlikely, and correspondingly fall in its tails. The blob outcomes occupying <strong>the biggest proportion</strong> along the center correspondingly line up with the center of the bell, showing that the Central Limit Theorem emerges geometrically from the branching structure of a binomial sample space. Zooming out from the coin-toss example, this is applicable to any binomial process. </p>
<p>Is this news? Perhaps not. But it is very cool to see how probability can be translated into areas and proportions, which can in turn reveal the underlying probability distribution for a specific outcome in a visual, geometric manner. </p>
<p>I used Perplexity with Claude 4.5 Sonnet to work through my ideas. Originally, I began making the above graphs and experiments during class when I got carried away trying to solve a problem by drawing boxes, which led to me seeing the staircase pattern (in the context of rigged coins), and following the clearest patterns. It walked me through how this nicely ties up in a way math-minded readers will enjoy:</p>
<blockquote>
<p>What we&#39;ve visualized here is actually a rotated form of Pascal&#39;s triangle—a well-established mathematical structure where each number is the sum of the two numbers above it. The connection runs deep: at each flip number <strong>N</strong>, counting how many paths lead to exactly k heads gives you the entries in row <strong>N</strong> of Pascal&#39;s triangle. These are the binomial coefficients C(N,k), which represent the number of ways to choose k items from N. When we divide each row by 2^N to convert counts into probabilities, we get the binomial distribution. The Central Limit Theorem then guarantees that as <strong>N</strong> grows large, this distribution approaches the normal curve—which is exactly what we see in our visualization. The geometry of branching paths through sample space doesn&#39;t just resemble Pascal&#39;s triangle; it is Pascal&#39;s triangle, revealing why the bell curve emerges so naturally from repeated binary trials.</p>
</blockquote>
<p>I will have to research further the math-y bits, but it was cool to spend an evening chasing geometric intuition; I find it much better than swimming through formulas, personally.</p>
<p>If you found this useful or interesting, I&#39;m glad! Do consider writing a technical blog of your own. In an AI-dominated era, mindful writing is more valuable than ever. It is also very useful to enrich your own understanding of things. </p>
<p><small>1. I promise I did not go out of my way to write this blog post just to show the visualization of the proportion of heads. It is extremely cool, and reminds me a bit of slope fields.</small></p>
</article>
    
    <script>
        function isSafari() {
            return typeof safari !== 'undefined';
        }

        function isPhone() {
            const isMobileSize = window.matchMedia("(max-width: 768px)").matches;
            const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            return isMobileSize && isTouchDevice;
        }

        function shouldDisableNProgress() {
            return isSafari() || isPhone();
        }

        function finishProgress() {
            if (!shouldDisableNProgress() && typeof NProgress !== 'undefined') {
                NProgress.configure({ showSpinner: false, minimum: 0.1, speed: 200, trickleSpeed: 50 });
                NProgress.set(0.7);
                setTimeout(function() {
                    NProgress.done();
                }, 100);
            }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', finishProgress);
        } else {
            finishProgress();
        }
    </script>
</body>
</html>

